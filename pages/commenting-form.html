

<h2>Commenting form</h2>

<p>
	Righto, let's get onto a new solid block of functionality: allowing users to add comments.
	This adds a new block of HTML in comment-form.php, which reports any errors when the comment
	is made, a form to capture the usual comment information, and some business logic in
	lib/view-post.php and view-post.php to glue it all together.
</p>

<?php renderDiff('109bd357fdc29c189081810f1da2fa0199661d6b') ?>

<p>
	Let us have a look in detail at view-post.php, which is the page called by the web server
	when a single post is rendered. In the newly inserted code, we take these actions:
</p>

<ol>
	<li>Reset the errors variable to null i.e. we do not yet know if they are any errors.</li>
	<li>Detect if we are in a POST operation. If we are not (i.e. the page is just being rendered
		normally, rather than submitting a form) then don't do any more of this new stuff.</li>
	<li>Get the author name, website URL and comment message, and pass them to new
		function <code>addCommentToPost()</code> for validation and saving.</li>
	<li>This will return any resulting errors into the <code>$errors</code> array.</li>
	<li>If the comment-adding function successfully saves a comment to the database,
		redirect to self and exit. This will request the page again in GET mode.</li>
	<li>If the comment save failed (perhaps because a mandatory field was not supplied) then
		the errors array will contain the error message(s). Since this skips the
		redirection phase, the form is rendered within the same call, which allows the errors
		to be marked on the form.</li>
</ol>

<?php if (showTodoMessages()): ?>
	<div class="todo">
		If we get stuck for space, we could move this sidebar to the earlier
		place where we refactored the installer from GET to POST.
	</div>
<?php endif ?>

<div class="sidebar">
	<div class="heading">
		<p>What are GET and POST?</p>
	</div>

	<p>
		I've used these phrases a few times without explaining them, so let me do that now. GET and
		POST are two kinds of <strong>HTTP operation</strong>, and can be thought of rather like a
		mode that a web-connected device (like a browser or a server) operates in. Any web address
		can be visited in either mode, and the web application can take a different course of
		action depending on the mode used.
	</p>
	<p>
		When we visit a web site normally &mdash; such as the home page of our blog, say &mdash;
		we are in GET mode. This is the state that is suitable for <em>reading</em> things from
		a web server. Some pages containing a <code>&lt;form&gt;</code> also operate in GET mode,
		such as search forms, since these too are used to read information.
	</p>
	<p>
		Forms that may result in data being saved, on the other hand, should use POST. You can
		see this with the comment form we just installed; have a look for the
		<code>method="post"</code> declaration in the form tag.
	</p>
	<p>
		This was one of the reasons behind the earlier change to the installer: before the
		modification, visiting the URL would reset the database, which breaks the rule that GET
		operations are only for reading data. Swapping this to a POST form solved the issue.
	</p>
</div>

<?php if (showTodoMessages()): ?>
	<div class="todo">
		This hash is in the wrong order - I felt it was best to do this before the
		validation failure thing. In the long term maybe it would be simpler just to merge this
		with the code that introduces the feature?
	</div>
<?php endif ?>

<p>
	Adding a comment doesn't work yet, as the <code>INSERT</code> command is missing a value for
	the date of comment creation. Let's fix that now:
</p>
	
<?php renderDiff('56046941508c1d47b1e36180e2245e6dfa6bac9c') ?>

<p>
	So, that gets the success case working. However, if you test a failure condition (empty name
	field or an empty comment, the fields that <em>were</em> filled in now disappear. This is because
	a form does not by default contain values, so we have to add them manually.	
</p>

<p>
	Thus, we now set empty values for the GET case (no form submission) in view-post.php as well as
	the already existing POST case. Where we output the user-supplied data, we pass it through
	the PHP function <code>htmlspecialchars()</code>, which prevents any rendering problems if the
	user has used any HTML characters such as angle brackets.
</p>

<?php renderDiff('51582d22e7ace119cee6d6023f2a0351cd0d6505') ?>

<?php if (showTodoMessages()): ?>
	<div class="todo">
		Currently finished writing up to here.
	</div>
<?php endif ?>

<p>Render paragraphs in comments</p>
<?php renderDiff('fcf4ab21a9bae2bf86f0d26cc0acc1309a0c789b') ?>

<?php if (showTodoMessages()): ?>
	<div class="todo">
		These last four items are refactoring/tidying. At the least this section should be declared,
		as per the last page, and if this page gets too long, we could move a couple of them to the
		next page?
	</div>
<?php endif ?>

<p>Move install logic to separate file</p>
<?php renderDiff('81865f2f16d7237a4f9864f3756e5dce05e9e147') ?>

<p>Refactor SQL timestamp into new func, we'll need this next</p>
<?php renderDiff('38d6c09faf1721560de1b6182cb477afb4110aa1') ?>

<p>Send PDO object to create db function</p>
<?php renderDiff('ed6aaadb0045735b2d723bc67967076958589ae5') ?>

<p>Fix up out-of-date comment</p>
<?php renderDiff('d28456262905f8e334903bc827325c7d062119a2') ?>

