<h2>Introduction</h2>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		Comments, to-do items and critical notes appear in this sidebar, in test environments
		only. These help collate and organise feedback.
	</div>
<?php endif ?>

<p>
	In this tutorial, I'll present how to write a simple blog system, using the PHP language and
	the Apache web server. For the database, we'll use SQLite, to keep things simple. Don't worry
	if these terms don't mean anything yet, that's okay. I'm assuming readers are familiar
	with how to use their computer, but perhaps have not programmed before. That said, even a
	beginner's tutorial can get non-trivial quickly, so if you are brand new to programming, you
	may wish to research unfamiliar keywords (usually on the PHP website).
</p>

<p>
	The application we will build together was built prior to writing the tutorial. The text is
	therefore written around the way I think development happens in real life; some steps may
	introduce bugs, or be written in ways the purist might consider non-ideal. However, for the most
	part, these problems will be ironed out as we go. At the end of this project, we'll have a
	<b>functional</b>, <b>maintainable</b> and <b>secure</b> application, but there'll be much
	that can still be improved on (which will likely make for a subsequent tutorial).
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		The site has a working title of 'I â™¥ PHP' (or "ilovephp" in URLs).
		I did wonder if 'I love code' would be better, in case other languages might be added in
		the future, but I think that might be too ambitious!
	</div>
<?php endif ?>

<p>
	If you are new to programming, it is possible that you might feel somewhat lost as you work
	through the material. Whilst any prior practice will always help, the before-and-after code
	samples should see you right through to the end, even if you don't initially understand every
	step. You should find that some of this will sink in, and will contribute to your future "aha"
	moment, even if it is daunting at the start. The elation of getting it working will, I hope,
	encourage you to dive even deeper into programming. Enjoy the ride!
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>A word about PHP tutorials on the web</p>
	</div>
	<p>
		To become proficient with a programming language, it makes sense to obtain your learning
		materials from as wide a source as possible. PHP owes its success, I think, to its very
		low barriers to entry, but that situation has given birth to plenty of tutorials on the
		Internet that make two fundamental errors.
	</p>
	<p>
		The first is that the <code>mysql_</code> library is still in use (a <em>library</em> is
		just a package of useful functions). This has been a staple of database access
		in PHP applications for some ten years, but has now been superceded by newer systems.
		In particular, libraries such as PDO and mysqli offer <em>parameterisation</em>, a feature
		that helps prevent miscreants and ne'erdowells from cracking system security.
	</p>
	<p>
		The other problem I see a great deal of are tutorials that interleave <em>business logic</em>
		(what an application does) with <em>layout</em> (what an application looks like).
		This isn't wrong exactly, but having separation between the two does tend to make
		for systems that are more maintainable.
	</p>
</blockquote>

<p>
	I'll assume that your development environment is set up. Here's what you will need:
</p>

<ul>
	<li>Web server, usually Apache</li>
	<li>PHP; anything over 5.3.7 is fine, although the latest version is usually best</li>
	<li>SQLite PHP module</li>
</ul>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		I've swapped out references to MAMP and WAMP, as MAMP is quite restricted in the free
		version (only one vhost) and it's nice to have one product for all systems.
	</div>
<?php endif ?>

<p>
	For Windows and Mac users, you can get all of this with
	<a href="https://www.apachefriends.org/">XAMPP</a>. If you use Linux, you may have all of this
	already &mdash; although XAMPP works on Linux too, and adds a user-friendly control panel.
	If you get stuck, turn to your favourite search engine, and
	ask "How do I install [whatever] on [Windows]". In 99% of cases, your question has already
	been answered, so be persistent.
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note" style="margin-top: 80px;">
		It might be nice to recommend something lightweight too, in addition to NB.
		<a href="http://brackets.io/">Brackets</a> and
		<a href="http://www.lighttable.com/">Light Table</a> are both free, in frequent development
		and x-platform - add one of these?
	</div>
<?php endif ?>

<p>
	You'll also need an editor to modify files. Most computers have a free text editor already
	installed, but these are rarely good enough. Use whatever you like, but if you have no
	preference, download and install NetBeans.
</p>

<div class="intermission">~</div>

<p>
	In designing this tutorial, I wrote out a list of things I thought would be great to have, and
	then developed until I had a basic complete product. In retrospect, it would have been better to
	decide this prior to development; regardless of whether you are setting up a business or programming
	for fun, having a simple and achievable plan is miles better than an all-singing,
	all-dancing one that ends up abandoned half-way through (either through boredom, bankruptcy, or
	both).
</p>

<p>Here's the initial list of features/technologies I put on paper:</p>

<blockquote class="list">
	<p>
		Login, Logout, Add comment, Create user, Amend user, Delete user, Email validation for new user
		accounts, Display post, Accept markdown format, Create post, Edit post, Unpublish post, Delete post,
		Unit tests, List posts, AJAX posting/commenting, Database profiler, Internationalisation,
		Pretty URLs, Use template engine, Per-environment configuration files, Post pagination,
		Comment pagination, Unpublish comment, Delete comment, Foreign key constraints, Unique constraints,
		User access levels.
	</p>
</blockquote>

<p>
	To illustrate how much an "initial working product" should trim the initial wishlist, here's
	what made it into the first version:
</p>

<blockquote class="list">
	<p>
		Login, Logout, Add comment, Display post, Create post, Edit post, Delete post, List posts,
		Delete comment, Foreign key constraints.
	</p>
</blockquote>

<p>
	It's worth pointing out that, with any software project, rejecting a feature <em>now</em> does
	not mean you can never add that feature. It just means that you are prioritising getting
	important things done, so that the product is in a releasable state quickly. Once it is out the
	door, you can then find a few more items on your list to add into the next iteration. In a
	commercial situation, this approach is helpful because if your users don't like a change you've
	made, you've wasted two months rather than two years &mdash; a saving that could be the difference
	between steering things back on track, and going bust.
</p>

<p>
	One of the other features of this tutorial is that it uses an absolute minimum of additional
	software to get it working. Software projects nearly always make use of libraries,
	each of which offer some particular pre-written functionality. These are well worth using in
	proper development, since they are better-tested by more people than an individual can usually
	achieve on their own. However, for a tutorial I think they can add integration complexity, and
	explaining the advanced-level code within is usually quite a distraction. Thus, I have eschewed
	libraries more than I would normally, and suspect this will be corrected in a second (more
	advanced) tutorial.
</p>
<p>
	I have made one exception for this rule, however, for reasons of password security. The login
	system requires some cryptographic code, and this sort of thing is quite easy to get wrong. Whilst
	this is just a tutorial, if it teaches readers to leave security to the experts (the
	library-writers), it has served a valuable purpose.
</p>

<div class="intermission">~</div>

<p>
	So, let us get started. I'll assume you know how to create, edit, save and delete files in your
	editor, and that you can create folders as required. This might be in the root of your "htdocs"
	or "www" folder, depending on what you used to install Apache. You can use a subfolder of "blog"
	if you wish, or for more advanced users, feel free to set up a new vhost. So, when I use
	<code>http://localhost/</code>, you can assume I am referring to the root of your project, even
	if your URL is somewhat different.
</p>

<p>
	Let us first check that your server installation is working okay. Create a file called
	<span class="filename">info.php</span> in the root of your project folder:
</p>

	<?php include '../templates/info.php' ?>

<p>
	Then, run this in your browser, by accessing the URL <code>http://localhost/info.php</code>.
	You should see a PHP configuration page. If you do, then check you are running a version later
	than 5.3.7; if it is earlier than this (e.g. it is still on 5.2, or an early version of 5.3) then
	you will need to upgrade. If you don't see this screen at all, then check that you have created
	the file in the right folder.
</p>

<p>
	Once you have this working, and showing an acceptable version number, you can delete this file.
</p>

<p>Here's the first bit of code to add:</p>

<div class="first">
	<?php renderDiffFromComment('Add skeleton front page') ?>
</div>

<p>
	This is the initial file, so all we have to do is copy and paste it in. To do so, create
	<span class="filename">index.php</span> in the root of your project folder, open it in your
	editor, and ensure it is empty before pasting in the code. Then visit
	<code>http://localhost/index.php</code> in your browser, to ensure that you can see the
	initial mock-up of our blog's home page.
</p>

<p>
	If you can, then your first piece of coding is done! The language is HTML, which is understood
	by your web browser as a way to describe documents on the web. HTML is not actually a
	programming language: it is properly referred to as a <em>markup language</em>. The markup itself
	is made up of <em>tags</em> such as <code>&lt;body&gt;</code> and <code>&lt;h1&gt;</code>, each
	of which has an opening tag (without the slash) and a closing tag (with the slash).

	These
	are nested to form a hierarchy in the same way as an ordinary letter is hierarchical: instead of
	an envelope containing a document containing headings and paragraphs, we have an
	<code>&lt;html&gt;</code> containing a <code>&lt;body&gt;</code> containing
	<code>&lt;h1&gt;</code> and <code>&lt;p&gt;</code>. Easy peasy!
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What do the tags mean?</p>
	</div>
	<ul>
		<li><code>DOCTYPE</code>: this tells the browser to expect a particular dialect of HTML
			&mdash; in this case HTML5</li>
		<li><code>html</code>: this is the "envelope" for the whole document. It acts as a container for
			everything</li>
		<li><code>head</code>: this contains stuff about the document, such as the title</li>
		<li><code>body</code>: unsurprisingly, this contains the main part of the document</li>
		<li><code>h1</code>, <code>h2</code>, <code>h3</code>: title headings of decreasing
			importance</li>
		<li><code>p</code>: a paragraph of text</li>
		<li><code>div</code>: a "division", i.e. a section</li>
		<li><code>a</code>: a hyperlink</li>
	</ul>

	<p>We'll use a few more as we go on, but those are the main ones.</p>
</blockquote>

<p>
	Let us start improving our skeleton home page. One of the observations we can make is that there
	is a fair bit of repetition: there are two articles that both have a heading, date, summary
	and hyperlink. Since this is just test data, let us add a loop around the first article block
	and delete the second one.
</p>

<p>
	Here is how I am presenting the changes in this tutorial. This will be good practice for you,
	since all changes will be shown in this way. The approach of showing code changes like this is
	known as a <em>diff</em>, for obvious reasons (though the diffs I use are more colourful than
	the usual monochrome versions).
</p>

<?php renderDiffFromComment('Remove repetition and use a loop to generate dummy post data') ?>

<p>
	The rules for making these changes are simple: the code on the left shows the old file, and the
	code on the right shows the new one. Also, red lines are deleted, green lines are added. So,
	the two red blocks on the left are in the existing file, and can be removed. The green block
	on the right should be added. Where you see a solid horizontal bar across the whole diff,
	that's just a sign that some identical lines have been missed out for brevity.
</p>
<p>
	Thus, if you wish, you can delete both article blocks and replace them with the new loop block
	(containing the <code>for()</code> through to the <code>endfor</code>). However, the way this was
	actually written was as follows:
</p>

<ul>
	<li>Delete the second article</li>
	<li>Insert the start of the <code>for()</code> loop before the first article, on a new line</li>
	<li>Insert the end of the loop (<code>endfor</code>) at the end of the first article, on a new
		line</li>
	<li>Indent the contents of the loop (in most editors, you can do this by selecting the article
		markup and pressing the Tab key)</li>
	<li>Finally, the two snippets of PHP to output the <code>$postId</code> are inserted into the
		article
</ul>

<p>
	In summary, it doesn't matter too much how you apply these changes (or, indeed, any changes in
	this tutorial). That said, understanding the way in which changes are written in real
	life may help towards a greater understanding of the code. Don't worry though if you think you've
	made a mistake; the full file for each change is available above each one.
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What are loops?</p>
	</div>
	<p>
		The <code>for()</code> and <code>endfor</code> you have seen form a <em>loop</em> block. This is
		a way of telling PHP that you want the enclosed code to be run a number of times. In this
		case, it sets a value to 1, and carries on looping whilst that value is less than or greater
		than 3. For each iteration of the loop, the value is incremented by 1, which is carried out by
		the <code>++</code> operator.
	</p>
</blockquote>

<p>
	So, finally, refresh your browser screen, and make sure your changes work. You should now see
	<em>three</em> articles, each with a different heading and paragraph.
</p>

<div class="intermission">~</div>

<p>
	The next step we will take is to set up the database. We'll use a database system called
	SQLite (pronounced "see-kwel light") as it is really easy to connect to, and does not
	require a database server. Create the following two files in your project, paste in the contents,
	and then we'll discuss what they do.
</p>

<p>
	You'll notice that some changes in this tutorial &mdash; including one of these files,
	<span class="filename">data/init.sql</span> &mdash; has a name that contains a forward slash.
	This means that the file is stored in a sub-directory, and that you'll need to create that
	manually if it does not already exist.
</p>

<?php renderDiffFromComment('Add data fixtures') ?>

<p>
	This change comprises of two new files, a SQL file and a PHP file. I'll discuss the SQL file
	first.
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What is SQL?</p>
	</div>
	<p>
		SQL is a programming language for databases. It has been mostly standardised between different
		database systems, so it looks nearly the same regardless of whether you are connecting to
		MySQL or PostgreSQL or (as we are) SQLite. We will use it to set up our database initially,
		save information to our blog, and query information from our blog.
	</p>
</blockquote>

<p>
	Broadly, databases are stored in terms of <em>tables</em>, <em>columns</em> and <em>rows</em>. Each
	different kind of data we wish to store needs its own table, but to start with, we only have one:
	a post. The <code>CREATE TABLE</code> statement specifies which properties we want a post to have,
	namely:
</p>

<ul>
	<li>id: a unique identifier to help us tell posts apart</li>
	<li>title: the heading</li>
	<li>body: the main text of the article</li>
	<li>user_id: which user created the article (we'll use this later on)</li>
	<li>created_at: when the article was created</li>
	<li>updated_at: when the article was updated</li>
</ul>

<p>
	The column <code>id</code> has two particular features:
</p>

<ul>
	<li>We declare it as a <code>PRIMARY KEY</code> in order to mark it as the predominant unique
		identifier for the row. This makes it suitable to refer to the row from another
		table (which we will do later on)</li>
	<li>We specify the <code>AUTOINCREMENT</code> option, so unique values are generated for us
		by the database server automatically</li>
</ul>

<p>
	A blog post is therefore just a row added to the posts table, since each row has space to store
	all of these values. Once the table is created, we also create some dummy article data, using
	<code>INSERT</code>. The format of this command, as used in the SQL script, is simply thus:
</p>

<p>
	<code>
		INSERT INTO table_name (column_1, column_2, ...) VALUES (value_1, value_2, ...);
	</code>
</p>

<p>
	Now, the SQL file won't do anything on its own: we need a program to send the commands to
	the database. This is where the <span class="filename">install.php</span> file comes in; we'll
	run that whenever we want to set up the blog (or to wipe it and start again). I'll describe
	its broad features here, but do also read the comments in the code.
</p>

<?php if (showTodoMessages()): ?>
	<div class="todo note">
		Re-running the installer on a fresh vhost just now resulted in permission errors when
		trying to create the file. Can we add a check in the script?
	</div>
<?php endif ?>

<p>
	The first half of the code is written in PHP. Here, we use a series of <code>if()</code>
	statements to ensure everything goes smoothly. The variable <code>$error</code> is set to an
	error message if something goes wrong. Here are the steps we take:
</p>

<ul>
	<li>Ensure the database has not been created in the <span class="filename">data.sqlite</span>
		file. If it has, we require the file to be deleted manually, so that it is harder to
		accidentally overwrite data.
	</li>
	<li>
		SQLite will work fine with just an empty file, so we create one with <code>touch()</code>
		and report if there was any problems doing that (such as being disallowed by file system
		permissions).
	</li>
	<li>
		We then read the SQL script in using <code>file_get_contents()</code> and report an error
		if the file cannot be found (this is unlikely, but it is good practice to check
		everything that can go wrong!).
	</li>
	<li>
		We then try running the SQL commands using <code>$pdo->exec()</code> and report any issues
		with that.
	</li>
	<li>
		Finally, we count the number of post rows we have created.
	</li>
</ul>

<p>
	The second half of the file (from <code>&lt;!DOCTYPE html&gt;</code>) presents the results of
	the script, in HTML.
</p>
<p>So, if you have not already tried it, visit <code>http://localhost/install.php</code> in your
	browser, and make sure some posts are created. If you want to re-run it, delete the data.sqlite
	file manually and refresh your browser page.
</p>

__NEWFILE__

<h2>Using real data</h2>

<p>
	Since we now have some data in our database, we can change our home page to render that data, rather
	than the mock data it has now. It's worth noting though that the process of designing the page
	with dummy data hasn't been a waste of time; using a mock-up is often a valuable part of deciding what
	a page should contain, and where those elements should go. So, make these changes next:
</p>

<?php renderDiffFromComment('Convert front page to read from database') ?>

<p>
	The first few lines determine the file path to the database, and then we create a new PDO object
	with <code>new PDO()</code>, which we can use to access the data. We then use the
	<code>query()</code> method to run a SQL statement that reads articles from the <code>post</code>
	table.
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What is a SELECT statement?</p>
	</div>
	<p>
		The <code>SELECT</code> command is used to read from the database. For a single table, it takes a
		format like this:
	</p>
		
	<blockquote class="code"><pre><code>SELECT
	(column names in a list)
FROM
	(table)
WHERE
	(condition)
ORDER BY
	(column names to sort on)</code></pre></blockquote>

	<p>
		The <code>WHERE</code> is optional, and is useful if we want to filter on some particular
		feature of each row.
	</p>

	<p>The statement is often written on a single line, but it can be split up as here, for readability.</p>
</blockquote>

<p>
	So, refresh your browser's view of <code>http://localhost/index.php</code>, and ensure that your
	new changes render the posts from the database without errors. I'll then explain what is happening.
</p>

<p>
	After connecting to the database, the query is used to retrieve column values for each table row,
	returning ordering the rows in <code>created_at DESC</code> (i.e. in reverse creation order, or most
	recent first). It then enters a loop (in this case a <code>while()</code>) to render all the posts it
	finds.
</p>

<p>
	We use <code>$stmt->fetch()</code> to read the next available row, until the point when there are no
	rows left. When that happens, this method will return false and the loop will exit.
</p>

<p>
	For every row, there are two observations worth making. Firstly, rows are returned in an array, so we
	access them using the array syntax such as <code>$row['title']</code>. Secondly, you'll see that
	where text strings are output, they are wrapped in the <code>htmlspecialchars()</code> function. The
	reason for this is that, if user input (a blog title or blog post in this case) contains angle brackets,
	it could break the HTML used in the page layout, and worse, might let a user inject unauthorised
	JavaScript that would be run on other people's computers.
</p>

<p>
	You'll notice that most of the PHP code to deal with the database side of things is in the top half
	of the file, and the second half is predominantly HTML. This isn't an accident: this arrangement creates
	a healthy separation between the two, which makes each easier to work with. Of course, there are a few
	cases where dynamic output is required inside the HTML, but these are kept deliberately short.
</p>

<div class="intermission">~</div>

<p>
	The next step is to create a page to show individual posts. Add the following file:
</p>

<?php renderDiffFromComment('Add post view page') ?>

<p>
	Now, it is our intention to link this page from individual posts on the home page. However, we've
	not quite done that bit yet, so let's visit the new page manually, in order to test it. Open a
	new tab, paste the link <code>http://localhost/view-post.php</code> into the address
	bar, and check that a simple post appears.
</p>

<p>
	
	The connection to the database is the same as before, but we now have a <code>WHERE</code> clause
	in our <code>SELECT</code> statement, and we are we are now using <code>prepare()</code> and
	<code>execute()</code> to send the statement to the database driver.
</p>
	
<p>
	Let's take the <code>WHERE</code> statement first. In the home page, we ran a query without
	this, because we wanted everything in the table. However it is more often the case that we
	want to limit returned rows to those matching one or more conditions. This is where the
	<code>WHERE</code> comes in. For our new page, we only want rows that have a specific id (and
	since "id" is unique, we know we won't get more than one).
</p>

<p>
	You'll notice that "id" is fixed to 1 (i.e. the first post). We'll fix that later, since of
	course this should depend on the post the user clicks on.
</p>

<p>
	The other change is swapping out the call to <code>query()</code> with two new methods.
	<code>prepare()</code> is used to set up the statement, and indicates with a colon where values
	should go (i.e. ":id"). The <code>execute()</code> statement then runs the query, swapping
	place-holders with real values (in this case, the number 1). This technique is known as
	<em>parameterisation</em>, and is a good way to inject user-supplied input in a secure manner
	(the post ID is not yet user-supplied, but it soon will be).
</p>

<p>
	In fact, let's wire in the post page now. Make the following changes, and test that clicking
	on each 'Read more' link shows the appropriate post.
</p>

<?php renderDiffFromComment('Wire in the view post page to the front page') ?>

<p>
	Alright, so let's make some nice easy changes now. A look at our
	<span class="filename">index.php</span> and <span class="filename">view-post.php</span>
	files shows that our blog title and synopsis is repeated in both files. That's not good, since
	if these things need to be amended, we need to change them more than once. Happily, the
	solution is easy: we create a PHP file for the duplicated snippet, and then use
	<code>require</code> to pull it in.
</p>

<?php renderDiffFromComment('Centralise title section of page in an HTML fragment') ?>

<p>
	Once that is done, we can see there is still some duplication, this time with the database
	PHP code. So, let's fix that too! You'll notice here that we're using a subfolder for
	<span class="filename">lib</span>:
	this is a very common name for library code folders.
</p>

<?php renderDiffFromComment('Centralise some database code') ?>

<p>
	The process of spotting code improvements (e.g. to reduce repetition) is known as
	<em>refactoring</em>, and it can be thought of as "cleaning as you go". Projects that are
	subject to these improvements are, at least in theory, more maintainable than ones that only
	get feature changes.
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What is a function?</p>
	</div>
	<p>
		We saw in the <span class="filename">common.php</span> library a set of code blocks that
		start with the word
		<code>function</code>. These are named blocks of code that can be called from different
		places, and are an essential item in your toolkit. They help reduce duplication (since
		you don't need to write code again) and they help improve modularity (since functions
		can be stored in separate files).
	</p>

	<p>
		The functions we've seen here all provide a <em>return value</em>, which is the result of
		the function, and it can be of any type: a number, a string, whatever. This can either be
		printed out to the screen, or more frequently, stored in a variable at the place it is
		called. For example, the function <code>getRootPath()</code> gets the full directory
		name of your web project on disk.
	</p>
</blockquote>

__NEWFILE__

<h2>Adding more features</h2>

<p>
	It is normal practice to link the main heading of a website to the home page, as this makes
	for a consistent navigation experience. So, let's do that now:
</p>

<?php renderDiffFromComment('Make title link to the home page') ?>

<p>
	Next, let us add in some logic that interprets two carriage-returns in a post as a paragraph
	break. Here we go:
</p>

<?php renderDiffFromComment('Put in real paragraphs in the article view') ?>

<p>
	Now, the default date style used around the application isn't very readable, so let's
	improve that now:
</p>

<?php renderDiffFromComment('Format the dates nicely') ?>

<p>
	Now we've done a bit of tidying, let's tackle a bigger item of functionality. We need
	to allow users to comment on articles, so let's make the necessary database changes to
	prepare for that:
</p>

<?php renderDiffFromComment('Add comments to fixtures') ?>

<p>
	Since this involves database changes, we'll need to delete our database file, and re-run
	the installer. So, delete the file in <span class="filename">data/data.sqlite</span> and then
	reinstall by visiting <code>http://localhost/install.php</code> again.
</p>

<p>
	You might ask why we are putting so much effort into an installer when we're nowhere
	near having a piece of finished software. The answer is that this installer is for us,
	the developers, and not for end users. Thus, it is something we want to set up reasonably
	early in our development lifecycle; whenever a database change is made, we want to be able
	to recreate our useful test data quickly and easily.
</p>

<p>
	Now we're ready to start adding some comment-related changes. To start with, let's add
	a count of comments on the front page. This uses the SQL command <code>COUNT()</code> to count
	the number of rows that would be returned by a query:
</p>

<?php renderDiffFromComment('Add comment counts to front page') ?>

<p>
	Also, we'll add a comment listing to individual post pages:
</p>

<?php renderDiffFromComment('Add comments/count to view post page') ?>

<p>
	So, give that a whirl. You will want to check the new count on the homepage, and the comments
	feature on individual posts. How's that looking?
</p>

__NEWFILE__

<h2>Improving the installer</h2>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		I think the first person voice here is okay - the tutorial starts off with it, so it's
		consistent.
	</div>
<?php endif ?>

<p>
	At this juncture, I decided to tidy up the installer a bit more. Firstly, it would be nice to
	see some data about what it has created; in the course of development you can expect
	to wipe and recreate your test data hundreds of times, so it's worth making the output
	useful.
</p>

<p>
	Secondly, as it stands it demonstrates non-optimal techniques, and fixing that gives me an
	opportunity to explain how to improve upon it. Broadly, the problem is that visiting the URL
	changes the database, but it does not take into account that web addresses can receive visits
	from automated software (e.g. search engines looking for new websites). To be sure that it
	is a human who has requested an install, I've used a form with a "post" method (this is
	explained in more detail later).
</p>

<p>
	The changes here are quite substantial, so you may find it easier to download the file, and
	copy the whole thing over the top of the old version. So, here's the diff:
</p>

<?php renderDiffFromComment('Get installer to install upon button press') ?>

<p>
	Finally, let's add some links so we can easily move to our next task after re-installing:
</p>

<?php renderDiffFromComment('Add helpful links in installer to home page, and self') ?>

<p>
	As is our custom, delete your database file and re-run the installer. This time you should
	have an "Install" button. All being well, it will do the same installation when you click it,
	and then you can opt to go straight to the blog's home page.
</p>

<div class="intermission">~</div>

<p>
	Since our changes to the installer have been brief, let's do some refactoring and a couple of
	minor functionality tweaks. Now, it could be said that this process of tidying seems rather
	erratic, and that similar items of work should be neatly collected together. However, real-life
	development rarely works that way: instead, a rough but usable solution is developed, and then
	improvements and refactorings are added depending on user feedback, and often also on time
	available.
</p>

<p>
	So, here's our first small improvement task. One of the things you may have noticed is that
	posts and comments are being marked as written on a particular day, but with no time
	information. It is usual to record and show this sort of data, so let's do that now. Don't
	forget to re-run the installer to test it!
</p>

<?php renderDiffFromComment('Convert all dates to datetimes') ?>

<p>
	Following on from our last bit of refactoring, here's another opportunity to tidy code. Arguably,
	the view post page has too much business logic in it, and it would be more maintainable
	to move this to a separate file. So, create <span class="filename">lib/view-post.php</span>
	and paste in the new content.
</p>

<?php renderDiffFromComment('Refactor some business logic to separate library file') ?>

<p>
	One of the situations we have not yet catered for is the user requesting a blog article
	that does not exist. We need to handle that based on the maxim that "if something can go
	wrong, it will". There are a good few small changes here, but in essence our approach is
	that if we cannot find a database row, we issue a browser redirect and show an error.
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		I've tested the new redirect code in <span class="filename">common.php</span> on a
		non-standard port, it works fine.
	</div>
<?php endif ?>

<?php renderDiffFromComment('Handle requests for non-existent posts') ?>

<p>
	Since the browser redirect is useful, it has been written as a function, and re-used by
	the installer. Although there is no new data to install, it is a good idea to delete your
	database file and re-install at this point, just to check it still works.
</p>

__NEWFILE__

<h2>Commenting form</h2>

<p>
	Righto, let's get onto a new solid block of functionality: allowing users to add comments.
	This adds a new block of HTML in <span class="filename">comment-form.php</span>, which
	reports any errors when the comment is made, a form to capture the usual comment information,
	and some business logic in <span class="filename">lib/view-post.php</span> and
	<span class="filename">view-post.php</span> to glue it all together.
</p>

<?php renderDiffFromComment('Add basic commenting form, validation and db error handling') ?>

<p>
	Let us have a look in detail at <span class="filename">view-post.php</span>, which is the page
	called by the web server when a single post is rendered. In the newly inserted code, we take
	these actions:
</p>

<ol>
	<li>Reset the errors variable to null i.e. we do not yet know if they are any errors.</li>
	<li>Detect if we are in a POST operation. If we are not (i.e. the page is just being rendered
		normally, rather than submitting a form) then don't do any more of this new stuff.</li>
	<li>Get the author name, website URL and comment message, and pass them to new
		function <code>addCommentToPost()</code> for validation and saving.</li>
	<li>This will return any resulting errors into the <code>$errors</code> array.</li>
	<li>If the comment-adding function successfully saves a comment to the database,
		redirect to self and exit. This will request the page again in GET mode.</li>
	<li>If the comment save failed (perhaps because a mandatory field was not supplied) then
		the errors array will contain the error message(s). Since this skips the
		redirection phase, the form is rendered within the same call, which allows the errors
		to be marked on the form.</li>
</ol>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		If we get stuck for space, we could move this sidebar to the earlier
		place where we refactored the installer from GET to POST.
	</div>
<?php endif ?>

<div class="sidebar">
	<div class="heading">
		<p>What are GET and POST?</p>
	</div>

	<p>
		I've used these phrases a few times without explaining them, so let me do that now. GET and
		POST are two kinds of <strong>HTTP operation</strong>, and can be thought of rather like a
		mode that a web-connected device (like a browser or a server) operates in. Any web address
		can be visited in either mode, and the web application can take a different course of
		action depending on the mode used.
	</p>
	<p>
		When we visit a web site normally &mdash; such as the home page of our blog, say &mdash;
		we are in GET mode. This is the state that is suitable for <em>reading</em> things from
		a web server. Some pages containing a <code>&lt;form&gt;</code> also operate in GET mode,
		such as search forms, since these too are used to read information.
	</p>
	<p>
		Forms that may result in data being saved, on the other hand, should use POST. You can
		see this with the comment form we just installed; have a look for the
		<code>method="post"</code> declaration in the form tag.
	</p>
	<p>
		This was one of the reasons behind the earlier change to the installer: before the
		modification, visiting the URL would reset the database, which breaks the rule that GET
		operations are only for reading data. Swapping this to a POST form solved the issue.
	</p>
</div>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		I've added this hash deliberately in the wrong order - I felt it was best to do this before the
		validation failure thing. In the long term maybe it would be simpler just to merge this
		with the code that introduces the feature?
	</div>
<?php endif ?>

<p>
	Adding a comment doesn't work yet, as the <code>INSERT</code> command is missing a value for
	the date of comment creation. Let's fix that now:
</p>
	
<?php renderDiffFromComment('Add timestamp to insert so comment device works') ?>

<p>
	So, that gets the success case working. However, if you test a failure condition (empty name
	field or an empty comment, the fields that <em>were</em> filled in now disappear. This is because
	a form does not by default contain values, so we have to add them manually.	
</p>

<p>
	Thus, we now set empty values for the GET case (no form submission) in
	<span class="filename">view-post.php</span> as well as
	the already existing POST case. Where we output the user-supplied data, we pass it through
	the PHP function <code>htmlspecialchars()</code>, which prevents any rendering problems if the
	user has used any HTML characters such as angle brackets.
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		We <em>could</em> split the comment in <span class="filename">comment-form.php</span>
		as one of those vars is already in use, but it's not important.
	</div>
<?php endif ?>

<?php renderDiffFromComment('Persist comment form data in case of validation') ?>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		These last five items are refactoring/tidying. If this page gets too long, we could move
		a couple of them to the next page?
	</div>
<?php endif ?>

<p>
	And now for some more tidying. The first tweaking opportunity I noticed was that the code to
	make a comment safe to render to the screen, and to swap newlines for paragraph tags, might be
	useful elsewhere in the future. So I've generalised that snippet of code in a function, and
	then made use of it:
</p>

<?php renderDiffFromComment('Render paragraphs in comments') ?>

<p>
	A nice simple one is up next. The code for <span class="filename">install.php</span> was
	rather bloated by the presence of the
	large function at the start, and there's no reason why this couldn't be stored separately,
	making the installer page easier to maintain. We refactored this one a while ago, but it's
	perfectly fine to refactor again &mdash; the process can be regarded as fairly iterative
	anyway. So here's the diff, resulting in new file
	<span class="filename">lib/install.php</span>:
</p>

<?php renderDiffFromComment('Move install logic to separate file') ?>

<p>
	When a comment is created, we use a snippet of code to create a timestamp in a format suitable
	for the database server. Since that'll be useful for other things, let's convert that to a
	reusable function:
</p>

<?php renderDiffFromComment('Refactor SQL timestamp into new func, we\'ll need this next') ?>

<p>
	I noticed that the installer creates its own database connection. Although there was no
	pressing need to do so, I modified it so it uses a connection passed to it. This would make it
	easier to run automated tests against it, for example &mdash; a custom test connection would be
	passed to it, rather than the "hard-wired" one we have now removed.
</p>

<?php renderDiffFromComment('Send PDO object to create db function') ?>

<p>
	The last tweak is very easy: a re-reading of some of the code showed that I'd not updated
	a comment in line with a code change. Now, I could magic this away for the benefit of the
	tutorial, but I rather like the opportunity to show that code is never perfect, and that
	sometimes comments come out of sync with what they're meant to describe! So, just apply the
	following diff, and we're done for this chapter.
</p>

<?php renderDiffFromComment('Fix up out-of-date comment') ?>

__NEWFILE__

<h2>Adding a login system</h2>

<p>
	The next thing I decided to implement was a log-on system. This will allow a blog administrator
	to write, edit and delete posts, and to delete comments. In this set of changes, I add a
	users table, and allow the installer to create an admin user with a new password each time it
	is run. So, make the following changes, and then re-create the database:
</p>

<?php renderDiffFromComment('Add user table, create user row when installing') ?>

<p>
	There are two fields in the new user table that I added based on my experience rather than an
	immediate need. These are <code>created_at</code>, which holds the date and time when the user
	was first set up, and <code>is_enabled</code>, which allows us to turn users on and off. Most
	user systems will find a practical use for these simple features during their lifetime.
</p>

<p>
	You'll have noticed a comment in <span class="filename">lib/install.php</span> noting that
	the password is stored in plaintext.
	This means that, as it stands, passwords would be stored literally, which is considered to be
	very bad practice indeed. What we should do is to store passwords in an encoded, non-reversible
	format, so that even if they are stolen they will be nearly impossible to read. This acts as a
	form of protection should a cracker get through our security and steal our database.
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		I was originally of the view that the library should be loaded only if the PHP version
		is &lt;5.5, but this feels a bit fussy. I think the note here to say that users
		on 5.5+ can omit these changes if they wish is a cleaner.
	</div>
<?php endif ?>

<p>
	So, let's make that improvement straight away. To do so, we'll need the library I talked about
	at the start of the tutorial, stored here in <span class="filename">vendor/password_compat</span>.
	The features it provides are so useful they have been built into PHP 5.5, so if you are running
	this version (or later) you can skip adding the new file and the associated
	<code>require_once</code>. However if you are running an earlier version, or if you are not
	sure which version you have, add all of these changes.
</p>

<?php renderDiffFromComment('Add password hashing capability') ?>

<p>
	So, what does the new code do? It makes use of a new function called
	<code>password_hash()</code>, which takes a password as input and produces what is known as a
	<em>hash</em>. A hash is a mathematical calculation that is strictly one way, which means that
	if sometimes steals our database of password hashes, they will find it very difficult indeed
	to recreate the passwords they were generated from.
</p>

<p>
	Whether or not you are using it, by all means do have a read of the source code in
	<span class="filename">password.php</span>. However, an in-depth exploration of it would be rather
	advanced at this stage, so for our purposes we will assume it just works.
</p>

<p>
	The next step is to add a login form, and a link from which to access it:
</p>

<?php renderDiffFromComment('Add skeleton for login screen') ?>

<p>
	In the next change, we add our familiar block of business logic before the main HTML. In this
	case, it checks to see if the form has been submitted; if it has, then it turns on the
	session system (more about that in a minute), creates a hash of the submitted password,
	and compares it with the hash stored in the database.
</p>

<p>
	If the user gets their username wrong (e.g. it is not found) or the password wrong (the
	password hash does not match the one for the username supplied) then we regard this as a login
	failure. It is important for us not to be too helpful here (such as explaining that a username
	does not exist), as this information might be useful to a system cracker.
</p>

<p>
	If the password matches however, then we call <code>login()</code> to sign in the user, and
	then we redirect to the home page using <code>redirectAndExit()</code>.
</p>

<blockquote class="sidebar">
	<div class="heading">
		<p>What are sessions?</p>
	</div>
	<p>
		Sessions are an extremely useful feature that allow web applications to
		remember per-user information. By default, every request to the server is seen in
		isolation, so without sessions, an application would not be able to
		remember that a user had signed in, or what their username was.
	</p>

	<p>
		To make sessions work, PHP sends the user's browser a cookie containing a random
		identifier, and for every subsequent visit, the browser supplies this back to the server.
		This identifier corresponds to a file on the server containing the variables that have been
		set for each user.
	</p>

	<p>
		PHP makes this nice and simple for developers: we just turn on sessions using
		<code>session_start()</code>, and then we can just read and write to the
		<code>$_SESSION</code> array. Easy peasy!
</blockquote>

<p>
	So, with that explained, let's add the changes:
</p>

<?php renderDiffFromComment('Get login system mainly working') ?>

<p>
	Now we have a way to determine whether users are logged in or not, let's switch that feature
	on for all pages. Here we also modify the HTML snippet that contains the page header, so
	it can show the appropriate login/logout link.
</p>

<?php renderDiffFromComment('Switch on sessions in all pages, recognise logged in/out') ?>

<p>
	You may have noticed, if you tried the logout link, that this page does not yet exist. So let's
	add that now in the following set of changes. Whilst we are at it, let's greet the user by
	their username while they are logged in, as this makes the experience of the site a bit
	more friendly.
</p>

<?php renderDiffFromComment('Add logout and username greeting') ?>

<p>
	That's all for this chapter, so give your application a good test, especially the new
	login and logout features. When you're ready, we'll proceed in the next chapter with some 
	small tweaks to improve what we have.
</p>

__NEWFILE__

<h2>Tidy up</h2>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		Have I over-iterated the point about refactoring? Read through earlier material.
	</div>
<?php endif ?>

<p>
	We've got a nice set of features working, but there are a good number of improvements and
	refactoring changes that can be made. Doing these periodically can make for easier and
	happier development, which in turn can improve your development efficiency.
</p>

<p>
	The first change is two-fold: pages were replicating some information in the header, and
	various items (the top menu bar and system messages) were using inline style rules rather than
	using class rules that need only be written once.
</p>

<?php renderDiffFromComment('Centralise CSS, switch various inline styles to classes') ?>

<p>
	Let's take a better look at the second change. Some of the original code was written like
	this:
</p>

<blockquote class="code">
	<code>&lt;div style="border: 1px solid #ff6666; padding: 6px;"&gt; &hellip; &lt;/div&gt;</code>
</blockquote>

<p>
	The purpose of the <code>style</code> attribute to specify CSS rules (otherwise known as
	style rules) to the HTML within. Firstly, we have the <code>border</code> rule, which says
	the content (an error message) should have a red border rendered in an unbroken line, and
	the <code>padding</code> means that there should be six pixels of gap between the border and
	an invisible box around the content.
</p>

<p>
	However, having to write that for every error message takes a bit of effort, and it's a
	pain if we decide that error messages should have a magenta border and not a red one. Thus,
	it makes life easier if we write this instead:
</p>

<blockquote class="code">
	<code>&lt;div class="error box"&gt; &hellip; &lt;/div&gt;</code>
</blockquote>

<p>
	That applies two rules to the block: one called <code>error</code> and another called
	<code>box</code>. That's much easier to remember, easier to read, and &mdash; since we
	centralise the definitions in <span class="filename">assets/main.css</span> &mdash; easier
	to change if we have to.
</p>

<p>
	While we are dealing with CSS changes, let's add a few more. Here we add some rules for
	article synopses, titles and dates on the home page, and comments on individual blog posts.
</p>

<?php renderDiffFromComment('Various CSS improvements') ?>

<p>
	You may have noticed that some function calls that need to access the database create their
	own connection rather than use one that we've already created. For low-volume systems this
	might not matter a great deal, but programmers hate this sort of inefficiency, and where it is
	trivial to fix, we should.
</p>

<?php renderDiffFromComment('Add a PDO param to functions, for consistency') ?>

<p>
	Now we improve the appearance of the comment form. It's worth opening up an article page
	prior to making the improvements, so you can refresh it after the CSS is in place. This will
	allow you to see the change quickly.
</p>

<?php renderDiffFromComment('Tidy up CSS for comment form') ?>

<p>
	We now turn our attention to an improvement to the database. This consists of the tables
	<code>post</code> and <code>user</code>, for blog posts and authors respectively. When
	creating a post record, we insert our automatically generated <code>user.id</code> in
	<code>post.user_id</code> to store which user has authored it (of course, we only have one 
	user in our test data, but in practice we might have several).
</p>

<p>
	However, it is possible to insert any number in <code>post.user_id</code>, so if we have
	an undiscovered bug in our code, it might cause a non-existent user primary key to be stored
	here. Since we rely on values here always pointing to a user row, if a bad value were to get
	in, it might crash our application.
</p>

<p>
	To protect against that scenario, many database systems will allow the use of <em>foreign key
	constraints</em>. These allow us to specify that values inserted into a particular column must
	exist in another column belonging to another table, and that an error must occur if this
	condition is not met. SQLite offers this feature, although it is unusual in that it needs to
	be turned on explicitly, using the <code>PRAGMA</code> command.
</p>

<p>
	So, let's make these changes:
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		Deleting the <code>user</code> table does not result
		in a constraint violation, since we refuse to run the SQL unless the database file is
		manually deleted.
	</div>
<?php endif ?>

<?php renderDiffFromComment('Enable foreign key constraints') ?>

<p>
	Here's what's new:
</p>

<ul>
	<li>
		Since we want posts to reference users, we need a user first. Thus, I've swapped the
		order around, so the test user is created before the test post</li>
	<li>
		We now need the test user to be created immediately in order to satisfy the foreign key
		constraint, so we <code>INSERT</code> that in the script with a dummy hash value, and
		<code>UPDATE</code> it afterwards with the real hash generated in PHP</li>
	<li>
		Now when we make database connections in <span class="filename">common.php</span>, the
		first thing we do is to switch on foreign key constraints</li>
</ul>

<p>
	As usual: delete your database file, re-run the installer, and check all the changes appear
	to work.
</p>

<p>
	The last change is related to security. Since all of our files are in the web server's
	public directory, a user who knows our directory structure would be able to download files
	that we didn't intend to make accessible. Since SQLite uses a single file to store its data,
	and since this file is often stored in a web-accessible location, it is of particular
	importance to lock this down.
</p>

<?php renderDiffFromComment('Prevent direct downloaders nicking the database etc') ?>

__NEWFILE__

<h2>New post creation</h2>

<p>
	Let's turn our attention to another major feature: writing a new article. We start off with
	setting up a new page, laying out the necessary form input controls, and adding a new logged-in
	menu item. There's also a change here to add a generic class <code>user-form</code>, so our
	forms across the whole application can easily acquire a common look-and-feel; see how I've
	gone back to existing form <span class="filename">comment-form.php</span> to update that too.
</p>

<?php renderDiffFromComment('Add in skeleton for New Post form') ?>

<p>
	Now, we only want to show this page for users who are logged in. Thus, if a user who is
	not logged in tries to access it (by typing the URL in directly) we must redirect them
	elsewhere; in this case, the home page will do fine.
</p>

<?php renderDiffFromComment('Only allow authenticated users on the New Post page') ?>

<p>
	While we are here, let's take a look at how <code>redirectAndExit()</code> works; this is in
	<span class="filename">common.php</span>. It starts by reading the domain we are running
	on (such as <code>localhost</code>), since it is good not to hardwire this into our code.
	It then sends a <code>Location</code> HTTP header to the browser, which will cause it to
	request the specified address. Since the PHP script would happily carry on running at this
	point (until it has detected that the browser has disconnected) we also need to forcibly
	exit and wait for the redirect.
</p>

<div class="sidebar">
	<div class="heading">
		<p>What are HTTP headers?</p>
	</div>

	<p>
		HTTP is the protocol that the internet uses to request data - web pages, API requests and
		file downloads can all be obtained this way. It's an open standard, which means that
		a browser (or any other piece of software) that implements the standard correctly can
		be assured of reliable inter-operability with other software on the web.
	</p>

	<p>
		HTTP operations are comprised of two parts: a <em>request</em> from one party to another,
		and a <em>response</em> back the other way. Part of the standard allows both requests
		and responses to be supplied with header data that describes its content.
	</p>

	<p>
		Some of the headers that can be supplied with a request are:
	</p>

	<ul>
		<li>Some information about the browser and operating system in use
			(the <code>User-Agent</code> header)</li>
		<li>Which website we wish to view (<code>Host</code>)
		<li>The cookies previously served by the domain (<code>Cookie</code>)
	</ul>

	<p>
		And the following are some common response headers:
	</p>

	<ul>
		<li>Some information about the server environment in use (<code>Server</code>)</li>
		<li>The type of the content; web pages for example are served as "text/html"
			(<code>Content-Type</code>)</li>
	</ul>
</div>

<p>
	Although we now have the structure of the new post feature, it does not work yet. So let us
	fix that now:
</p>

<?php renderDiffFromComment('Add basic new post functionality') ?>

<p>
	In a similar way to saving comments, we first test if we are in a post operation, using
	<code>if ($_POST)</code>. This contains an array of input values that will be only be present
	if a user has submitted the form.
</p>

<p>
	We then make some simple checks to ensure the form data is acceptable prior to our attempting
	to insert it into the database. This is a process known as <em>form validation</em> and is
	a frequent task within web application development. If any checks fail, we allow the page to be
	rendered in the POST request itself, plus error messages as appropriate, and it is only if the
	checks succeed that we try to save the data and redirect back to the newly committed article.
</p>

<p>
	However, as it stands this redirect will just display a new, empty post, since we have not
	added the logic to render the edit facility for a specific row. Let's add that now:
</p>

<?php renderDiffFromComment('If a post ID is supplied, show that post in the editor') ?>

<p>
	That was nice and easy: if we find we are not in a post operation <em>and</em> we have a
	post primary key <em>and</em> that row exists, then show it in the edit form. You can see that
	now we need the database connection (in <code>$pdo</code>) for two things, I've moved
	that line so that it is always executed.
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		Whether to trust the user with raw HTML is a complex area - maybe add a sidebar on this?
		Or is this too much detail?
	</div>
<?php endif ?>

<p>
	As we have done before, this code uses <code>htmlspecialchars()</code> to prevent users
	from entering HTML, which could break our page layout or introduce security problems. It is
	perhaps less of a worry here, since at least these users are authenticated, and hence
	they might be considered more trustworthy than anonymous commenters.
</p>

<p>
	If you tried editing a post, you'll have found that this created a new post, rather than
	updating the old one. So let's fix that also:
</p>

<?php renderDiffFromComment('Make amendments to posts an update rather than an insert') ?>

<p>
	I've moved the code to read the current post towards the start of the page, since this is
	now useful in two situations. The first is when displaying an article for
	editing, and the second is when submitting the edit form to save any changes.
	In both cases, <code>$_GET['post_id']</code> will be available, and we can look up that row
	from the post table, and obtain title/body data if it is read successfully.
</p>

<p>
	Within a POST operation, we can then check <code>$postId</code>, and if it has a value we
	know we are editing an existing article rather than creating a new one. Thus, if we are editing,
	we call the new function <code>editPost()</code>, which will run the necessary
	<code>UPDATE</code> command against the database, rather than <code>addPost()</code>, which
	would run an <code>INSERT</code>.
</p>

<p>
	You might have noticed that there has been no attempt to check whether the user editing a
	post is the same as the user who wrote it. Whether one person may edit other person's posts is
	a feature decision, but for the time being it is one that I have deliberately omitted, to
	keep things simple.
</p>

__NEWFILE__

<h2>Post editing</h2>

<p>
	In this chapter, we will build on our new editing functionality, but first, let's simplify
	the title HTML block by moving the menu into a separate file:
</p>

<?php renderDiffFromComment('Separate the top menu into a new file') ?>

<p>
	That change allows us to wire in the menu fragment separately, without the
	title, so we can use a custom title in the edit page. You'll see that we set the title to
	"New post" or "Edit post" depending on whether we can find a primary key in the query string.
</p>

<?php renderDiffFromComment('Add in custom title in edit post') ?>

<p>
	Let's also add in a cancel link in the edit page, to make it easier to abandon an edit:
</p>

<?php renderDiffFromComment('Add in cancel link in edit post') ?>

<p>
	On the home page, and for logged-in users only, I next added an edit link against each post,
	like so:
</p>

<?php renderDiffFromComment('Add an edit link for users who are logged in') ?>

<p>
	You may have noticed that the class name (<code>read-more</code>) of the wrapping div was no
	longer accurate, which is why I changed this to something more generic. As it happens, this
	section doesn't have any CSS rules specifically attached to it, but it's good to have something
	for future styles to hook onto).
</p>

<p>
	Lastly, let's make a another nice easy change - there's no point in rendering the login
	page if we are already logged in. So, after the session is started, if we find we are logged
	in already, redirect back to the home page.
</p>

<?php renderDiffFromComment('Redirect on login page if we\'re already logged in') ?>

__NEWFILE__

<h2>All posts page</h2>

<p>
	The next step is to add an All Posts screen for administrative users. We'll start with
	a static mock-up with hard-wired post values:
</p>

<?php renderDiffFromComment('Add mockup of All Posts screen for admin users') ?>

<p>
	Of course, since this is a restricted screen, we must only allow authorised users to see it.
	To do so, we redirect back to the home page, and exit as usual:
</p>

<?php renderDiffFromComment('Only allow auth users to see the All Posts screen') ?>


<p>
	Great stuff. Don't forget to test it by logging out, and then trying to visit the page
	manually!
</p>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		This sidebar section might be slightly better melded into the text, which is
		pretty light at the moment anyway.
	</div>
<?php endif ?>

<blockquote class="sidebar">
	<div class="heading">
		<p>What do square brackets in form elements do?</p>
	</div>
	<p>
		Aha! Glad you asked. First, let's consider this simple form element:
	</p>

	<blockquote class="code">
		<pre><code>&lt;input type="submit" name="save" value="Save" /&gt;</code></pre>
	</blockquote>

	<p>
		This is pretty simple. If the button is pressed, the form is submitted, and the submitted
		key <code>save</code> gets the value of the button, "Save".
	</p>

	<p>
		However, consider the scenario where we need several submit buttons carrying out a similar
		purpose, e.g. a delete button per database row. One solution is to add in the primary key
		as part of the name:
	</p>

	<blockquote class="code">
<pre><code>&lt;input type="submit" name="delete_1" value="Delete" /&gt;
&lt;input type="submit" name="delete_2" value="Delete" /&gt;
&lt;input type="submit" name="delete_3" value="Delete" /&gt;</code></pre>
	</blockquote>

	<p>
		When this form gets submitted, we can search for keys matching this naming specific pattern,
		and delete the matching row as appropriate. However, this is rather fiddly, so PHP
		provides a cleaner solution - the square bracket syntax:
	</p>

	<blockquote class="code">
<pre><code>&lt;input type="submit" name="delete[1]" value="Delete" /&gt;
&lt;input type="submit" name="delete[2]" value="Delete" /&gt;
&lt;input type="submit" name="delete[3]" value="Delete" /&gt;</code></pre>
	</blockquote>

	<p>
		This helps up cheat by doing some of our parsing for us. Here's what happens in that form
		if we press the second Delete button:
	</p>

	<blockquote class="code">
<pre><code>Array
(
    [delete] => Array
        (
            [2] => Delete
        )
)</code></pre>
	</blockquote>

	<p>
		This makes things nice and easy: we just look up the name of the element
		(i.e. <code>delete</code>), and then grab the first key value.
	</p>
</blockquote>

<p>
	Now, the logic we use to read the posts for the front page will be useful also for this
	new screen. Since we don't want to write this twice, let's move it to a function so we can
	reuse it later on.
</p>

<?php renderDiffFromComment('Move home page logic to central location, so we can reuse it for All Posts') ?>

<p>
	While working on the home page, I noticed I'd used the variable name <code>$row</code>. This
	is rather generic &mdash; most things read from a database are rows &mdash; so I swapped to
	a better name for it. This is more readable, and fits in with the common naming convention
	of using a plural name for an array and the corresponding singular name for each item.
</p>

<?php renderDiffFromComment('Improve the name of this variable') ?>

<p>
	Next, we'll modify the mock-up by adding in a creation time for posts:
</p>

<?php renderDiffFromComment('Add in creation time to All Posts') ?>

<p>
	As with our mock-up approach before, once a layout contains everything required, it is time to
	convert to a working version. So, let's do that now: we'll add a loop and render table data in
	the HTML.
</p>

<?php renderDiffFromComment('Wire in database calls for All Posts screen') ?>

<p>
	As it stands, the user may click on a delete button to remove a post, but this is not
	presently handled. So, let's do that now:
</p>

<?php renderDiffFromComment('Add delete post feature') ?>

<p>
	Finally let's add in a post count on this page:
</p>

<?php renderDiffFromComment('Add in post count on All Posts page') ?>

__NEWFILE__

<h2>Comment admin</h2>

<p>
	In this section, we'll allow authorised users to delete comments from posts. To kick us
	off, here's a nice item of refactoring &mdash; the comments list within article pages is quite
	large, and it would be more modular to store it in a separate file.
</p>

<?php renderDiffFromComment('Move comments markup to separate template file') ?>

<p>
	Let us now add a delete button next to comments on blog posts, for authorised users only. I've
	added a bit of extra CSS to get it to float to the right-hand side.
</p>

<?php renderDiffFromComment('Add delete button to comments for auth users') ?>

<p>
	Since we want to do more than one thing with comments (add and delete), we need to
	make a change to explain what we are doing within the form submission. To do this, I've used
	the query string, which sends these items of information:
</p>

<ul>
	<li>The primary key of the post (<code>post_id</code>) upon which a comment is being added or
		deleted</li>
	<li>A name for the action (<code>add-comment</code> and <code>delete-comment</code>), which
		can be read by our code to determine what the user wishes to do</li>
</ul>

<?php renderDiffFromComment('Make changes to pave way for determining which form is being used') ?>

<?php if (showTodoMessages()): ?>
	<div class="comment note">
		We could add in a comment against the new line in <span class="filename">view-post.php</span>
		to explain that this new function will redirect upon success.
	</div>
<?php endif ?>

<p>
	Let us now make some room in our view post page, by moving some logic to a new function.
</p>

<?php renderDiffFromComment('Move logic to function, to make room for action test') ?>

<p>
	We now need to read the action key we set up, so we can decide what feature to call.
	If the user is deleting a comment, the new function <code>deleteComment</code> in the next set
	of changes is called; although we could just delete by <code>comment.id</code>, to be sure of
	deleting the right thing we filter additionally by <code>comment.post_id</code>.
</p>

<p>
	Note that we also add an <code>if()</code> clause to ensure that the delete operation is skipped if
	the user is not logged in. Although we do not render delete buttons for anonymous users, it is
	still possible for security crackers to fake a form submission that contains a valid deletion
	request &mdash; this clause prevents that.
</p>

<?php renderDiffFromComment('Get the delete comment feature working') ?>

<p>
	Finally, I noticed that the logic to add a comment is contained within a function, but the
	logic to delete one is still in the <code>switch()</code> block in
	<span class="filename">view-post.php</span>. The following change just tidies that up:
</p>

<?php renderDiffFromComment('Add new comment delete function at the same level of abstraction as comment adding') ?>

<p>
	As ever, test everything to check it works, before we proceed to the final chapter!
</p>

__NEWFILE__

<h2>Adding some polish</h2>

<p>
	Excellent, we're now on the home straight! Our functionality is finished, so we'll just
	do a last round of sprucing up. To start, let's add in a home link for authorised users. This
	is useful on the restricted pages, since they don't have a home link themselves:
</p>

<?php renderDiffFromComment('Add in home link for auth users') ?>

<p>
	Next, I thought it would be nice to have a comment count for each article on the All Posts page.
	Add the following changes:
</p>

<?php renderDiffFromComment('Add in comment count for each post') ?>

<p>
	Let's take a closer look at how the new query works. The query now looks like this:
</p>

<blockquote class="code">
<pre><code>SELECT
	id, title, created_at, body,
	(SELECT COUNT(*) FROM comment WHERE comment.post_id = post.id) comment_count
FROM
	post
ORDER BY
	created_at DESC</code></pre>
</blockquote>

<p>
	The new part of this is the bracketed expression on the third line. This
	sort of SQL is known as a <em>sub-query</em> since it is a query contained inside another
	one. The result of it can be read like a real column, which we explicitly name by adding
	<code>comment_count</code> at the end of it.
</p>

<p>
	This sub-query will count rows in the <code>comment</code> table, based on which post they
	belong to. Since the job of the outer query is to list posts, we can filter the comment count
	for each row by making a comparison to the outer table, <code>post</code>.
</p>

<p>
	The next change is another easy one: we'll add a header row to the All Posts table:
</p>

<?php renderDiffFromComment('Add heading to All Posts table') ?>

<p>
	While we are on the All Posts page, it would make sense to add in a link to the view page
	for each article. So let's do that now:
</p>

<?php renderDiffFromComment('Add view link from All Posts admin page') ?>

<p>
	Next up is a refactoring that simplifies the code (quite a bit is removed) and reduces the
	number of calls made to the database. The essence of the modification is in
	<span class="filename">lib/view-post.php</span> &mdash; we merge two SQL calls together via
	another sub-query.
</p>

<p>
	There's quite a few files to modify here, so make sure you get them all.
</p>

<?php renderDiffFromComment('Merge comment-counting into get post query') ?>

<p>
	I noticed when doing some testing at this point that posts which have comments cannot be
	deleted - try that now. You'll get an error known as a <em>foreign key constraint violation</em>;
	this is what happens when a row is deleted that a foreign key depends on (in our case we
	are trying to delete a post to which comments are still attached). To fix this, comments
	should be deleted first, prior to the post being deleted:
</p>

<?php renderDiffFromComment('Allow posts that have comments to be deleted') ?>

<p>
	Whilst we are looking at the database side of things, I noticed that the
	<code>user.is_enabled</code> field hasn't yet been used. This was intended mainly for future
	enhancements (in particular for a user administration page), but the application can make an
	initial use of it immediately, by disallowing authenticated features to non-enabled users.
</p>

<p>
	The installer sets the test user to <code>is_enabled=1</code> already, so all we need
	to do is to adjust the SQL statements that fetch data from the user table.
</p>

<?php renderDiffFromComment('Only look up users who are enabled') ?>

<p>
	Our final improvement is to add some labels and make use of existing form styles:
</p>

<?php renderDiffFromComment('Upgrade login form with global CSS features') ?> 

<p>
	Well done, you have finished the tutorial! It is a good idea to regenerate the database one last
	time, and then give the whole application a thorough testing. Add some posts and comments, both
	while logged in and while logged out, and delete comments in the admin interface.
</p>
